<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Qemu on kfei&#39;s brainfuck</title>
    <link>https://kfei.net/posts/tags/qemu/</link>
    <description>Recent content in Qemu on kfei&#39;s brainfuck</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 13 Jun 2014 09:05:00 +0800</lastBuildDate>
    <atom:link href="https://kfei.net/posts/tags/qemu/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Persistent cache in QEMU or librbd?</title>
      <link>https://kfei.net/posts/2014/06/persistent-cache-in-qemu-or-librbd/</link>
      <pubDate>Fri, 13 Jun 2014 09:05:00 +0800</pubDate>
      
      <guid>https://kfei.net/posts/2014/06/persistent-cache-in-qemu-or-librbd/</guid>
      <description>&lt;p&gt;我們知道無論是 QEMU 或是 librbd 都有提供 writeback cache. 同時也有兩個明顯的效能議題:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cache 的生命週期跟隨 QEMU process, 也就是說一旦 VM shutdown, cache 也就跟著消失.&lt;/li&gt;
&lt;li&gt;多個 QEMU process 間無法共享 cache, 而這在某些情境 (e.g. VDI) 下卻非常有用.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解決這兩個問題的方式無非是將 cache 持久化在一些高速裝置上. 事實上大約一年前在 QEMU 的 mailing list 上就&lt;a href=&#34;https://lists.gnu.org/archive/html/qemu-devel/2013-06/msg03649.html&#34;&gt;討論&lt;/a&gt;過這個議題, Ceph 的作者也發表了看法, 只可惜後續好像沒什麼進展?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>virsh error: Cannot allocate memory</title>
      <link>https://kfei.net/posts/2013/11/virsh-error-cannot-allocate-memory/</link>
      <pubDate>Mon, 11 Nov 2013 13:10:00 +0800</pubDate>
      
      <guid>https://kfei.net/posts/2013/11/virsh-error-cannot-allocate-memory/</guid>
      <description>&lt;p&gt;Today I was trying to increase memory size on a qemu-kvm hosted VM. My plan was as simple as shut it down and then change memory setting via &lt;code&gt;virsh edit &amp;lt;VMName&amp;gt;&lt;/code&gt;, but both &lt;code&gt;virsh edit&lt;/code&gt; and &lt;code&gt;virsh start&lt;/code&gt; throws the same error message:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;error: cannot fork child process: Cannot allocate memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s weird because &lt;code&gt;free&lt;/code&gt; shows me a sufficient amount of memory. But the fact is VM won&amp;rsquo;t boot anymore and even edit its definition file is impossible. Google gives me an answer: &lt;code&gt;sysctl -w vm.overcommit_memory=1&lt;/code&gt;, but it doesn&amp;rsquo;t work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# from kernel documentation
overcommit_memory:

This value contains a flag that enables memory overcommitment.

When this flag is 0, the kernel attempts to estimate the amount
of free memory left when userspace requests more memory.

When this flag is 1, the kernel pretends there is always enough
memory until it actually runs out.

When this flag is 2, the kernel uses a &amp;quot;never overcommit&amp;quot;
policy that attempts to prevent any overcommit of memory.
Note that user_reserve_kbytes affects this policy.

This feature can be very useful because there are a lot of
programs that malloc() huge amounts of memory &amp;quot;just-in-case&amp;quot;
and don&#39;t use much of it.

The default value is 0.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It does make sense! But seems qemu-kvm runtime parameter doesn&amp;rsquo;t affected by &lt;code&gt;sysctl&lt;/code&gt;, so I tried &lt;code&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory&lt;/code&gt; and it just works!&lt;/p&gt;

&lt;p&gt;Note that there are some useful actions for memory management:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 3 means release all cache, including pagecache, dentries, inodes
echo 3 &amp;gt; /proc/sys/vm/drop_caches
# compact memory such that free memory is available in contiguous blocks
echo 1 &amp;gt; compact_memory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still confused about why &lt;code&gt;free&lt;/code&gt; tells me OK, but &lt;code&gt;virsh start&lt;/code&gt; negative?&lt;/p&gt;

&lt;p&gt;ref. &lt;a href=&#34;https://www.kernel.org/doc/Documentation/sysctl/vm.txt&#34;&gt;https://www.kernel.org/doc/Documentation/sysctl/vm.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update 20131112&lt;/strong&gt;
Seems legacy libvirtd (in this case 0.12.0) has a memory leak issue under some situations, so &lt;code&gt;/etc/init.d/libvirtd restart&lt;/code&gt; may solve this problem better. Upgraded to 1.1.1 and watching&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>