<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on kfei&#39;s brainfuck</title>
    <link>https://kfei.net/posts/tags/docker/</link>
    <description>Recent content in Docker on kfei&#39;s brainfuck</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Sat, 06 Dec 2014 16:58:00 +0800</lastBuildDate>
    <atom:link href="https://kfei.net/posts/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Docker: 使用 s6 作為多服務容器的啟動管理程序</title>
      <link>https://kfei.net/posts/2014/12/docker-%E4%BD%BF%E7%94%A8-s6-%E4%BD%9C%E7%82%BA%E5%A4%9A%E6%9C%8D%E5%8B%99%E5%AE%B9%E5%99%A8%E7%9A%84%E5%95%9F%E5%8B%95%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sat, 06 Dec 2014 16:58:00 +0800</pubDate>
      
      <guid>https://kfei.net/posts/2014/12/docker-%E4%BD%BF%E7%94%A8-s6-%E4%BD%9C%E7%82%BA%E5%A4%9A%E6%9C%8D%E5%8B%99%E5%AE%B9%E5%99%A8%E7%9A%84%E5%95%9F%E5%8B%95%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F/</guid>
      <description>

&lt;h2 id=&#34;前言:8ac442f540b3d692a677bf03e4d50441&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在打包 &lt;a href=&#34;https://github.com/kfei/docktorrent&#34;&gt;docktorrent&lt;/a&gt; 的過程中，遇到了在 container 裡多服務的啟動和管理問題，包含 process init，signal handle，monitor，orphan reaping 等等。把 init process 的 survey 心得及最後決定的 image 架構記錄一下，有錯請指正。&lt;/p&gt;

&lt;h2 id=&#34;在一個容器裡跑多個服務-你確定:8ac442f540b3d692a677bf03e4d50441&#34;&gt;在一個容器裡跑多個服務？你確定？&lt;/h2&gt;

&lt;p&gt;雖然 Docker 官方總是建議一個 container 只跑一個特定服務，然而在很多情況下，將幾個高度耦合的服務封裝在同一個 container 中一起跑也是很乾脆的做法，相對於內建難用的 linking 或透過 fig 管理多 container，有時候還方便的多。&lt;/p&gt;

&lt;p&gt;聽聽 &lt;a href=&#34;http://phusion.github.io/baseimage-docker/&#34;&gt;Phusion&lt;/a&gt; 對於這個問題是怎麼說的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;But I thought Docker is about running a single process in a container?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Absolutely not true. Docker runs fine with multiple processes in a container. In fact, there is no technical reason why you should limit yourself to one process – it only makes things harder for you and breaks all kinds of essential system functionality, e.g. syslog.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We encourage you to use multiple processes.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;沒有-init-process-會怎樣:8ac442f540b3d692a677bf03e4d50441&#34;&gt;沒有 init process 會怎樣？&lt;/h2&gt;

&lt;p&gt;然而，一旦跑了多個 process，誰當老大（PID = 1）就會是個很重要的問題。在 docktorrent 一開始的打包方法中，我的 entrypoint 腳本大概是像這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Start satellite services
/etc/init.d/nginx start
/etc/init.d/php5-fpm start

# Turn to rTorrent
exec rtorrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是說把 nginx 和 php5-fpm 跑起來後，執行 rTorrent 並且把 PID 1 交給他。會讓 rTorrent 作為 PID 1 的原因在於 &lt;code&gt;docker stop&lt;/code&gt; 只會把 SIGTERM 送給 container 中的 PID 1 process，而 rTorrent 是整個 container 中唯一需要 graceful shutdown 的，所以讓他去接 signal。但這種做法馬上就會發現 &lt;code&gt;ps -ef&lt;/code&gt; 出現一大堆 &lt;code&gt;[php] &amp;lt;defunct&amp;gt;&lt;/code&gt; process，或許這是那些 PHP process 自己的問題，但作為 PID 1 的 rTorrent 不能好好回收這些孤兒，似乎也不太理想。一般來說，作為系統頭號 process 應該要負幾個基本責任：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;依序啟動所有該啟動的服務（process）然後常駐背景&lt;/li&gt;
&lt;li&gt;在系統終止時正常關閉（graceful shutdown）這些服務&lt;/li&gt;
&lt;li&gt;隨時回收系統上所有無主孤魂（orphan process）&lt;/li&gt;
&lt;li&gt;可以 respawn 異常掛掉的服務&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此就有必要找個（或者自幹一個）專職的 PID 1，也就是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Init&#34;&gt;init&lt;/a&gt; 程序來作為 container 執行時的入口。當然，考慮到最後的 image 要盡量精簡，像 Upstart，Systemd 或是 OpenRC 這種重型的方案在 container 環境就暫且先不考慮了。&lt;/p&gt;

&lt;h2 id=&#34;supervisord:8ac442f540b3d692a677bf03e4d50441&#34;&gt;Supervisord&lt;/h2&gt;

&lt;p&gt;於是首先看看 Docker &lt;a href=&#34;https://docs.docker.com/articles/using_supervisord/&#34;&gt;官方推薦&lt;/a&gt; 的 &lt;a href=&#34;http://supervisord.org/&#34;&gt;Supervisord&lt;/a&gt;，透過設定檔來配置服務的方式，試用了一下發現還算簡單易用，一個 &lt;code&gt;supervisord.conf&lt;/code&gt; 的內容大概是這樣寫：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[supervisord]
nodaemon=true

[program:sshd]
command=/usr/sbin/sshd -D

[program:apache2]
command=/bin/bash -c &amp;quot;source /etc/apache2/envvars &amp;amp;&amp;amp; /usr/sbin/apache2 -DFOREGROUND&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可惜 Supervisord 的設計並不是用來作為 init process 使用的，這在其首頁上已有宣告：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It shares some of the same goals of programs like launchd, daemontools, and runit. Unlike some of these programs, it is not meant to be run as a substitute for init as “process id 1”. Instead it is meant to be used to control processes related to a project or a customer, and is meant to start like any other program at boot time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;經過測試，Supervisord 在接收到 &lt;code&gt;docker stop&lt;/code&gt; 送來的 SIGTERM 時，會把訊號轉送給其他 process，等待所有服務 graceful shutdown。然而，孤兒 processes 的問題也確實沒有解決，整個 container 還是充滿 zombie。再說 Supervisord 是 Python 寫成的，要是疊加在 &lt;code&gt;debian:jessie&lt;/code&gt; 上足足要增加 45MB 的 image size，加上 Python 在執行階段的成本，僅僅為了跑多服務似乎不大划算。&lt;/p&gt;

&lt;h2 id=&#34;runit:8ac442f540b3d692a677bf03e4d50441&#34;&gt;Runit&lt;/h2&gt;

&lt;p&gt;下一位，&lt;a href=&#34;http://smarden.org/runit/&#34;&gt;Runit&lt;/a&gt;。Written in C，足夠輕量，疊加在 &lt;code&gt;debian:jessie&lt;/code&gt; 上只增加約 10MB 大小，貌似不錯。知名的 Phusion baseimage 系列也使用 Runit（不過只是用來做服務啟動和 supervision，對於 init process 他們自己寫了一隻叫 &lt;code&gt;my_init&lt;/code&gt; 的 Python 小程式）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/bin/runsvdir -P /etc/sv&lt;/code&gt; 是 Runit 掃描並啟動服務的方式，其中 &lt;code&gt;/etc/sv&lt;/code&gt; 是符合 Runit &lt;a href=&#34;http://smarden.org/runit/faq.html#create&#34;&gt;規定格式&lt;/a&gt;的 service directory。舉例來說在 &lt;code&gt;phusion/baseimage&lt;/code&gt; 裡的目錄結構是這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# tree /etc/service
/etc/service
|-- cron
|   |-- run
|   `-- supervise
|       |-- control
|       |-- lock
|       |-- ok
|       |-- pid
|       |-- stat
|       `-- status
|-- sshd
|   |-- run
|   `-- supervise
|       |-- control
|       |-- lock
|       |-- ok
|       |-- pid
|       |-- stat
|       `-- status
`-- syslog-ng
    |-- run
    `-- supervise
        |-- control
        |-- lock
        |-- ok
        |-- pid
        |-- stat
        `-- status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;掃到服務之後 &lt;code&gt;runsvdir&lt;/code&gt; 會將服務交由另一隻 &lt;code&gt;runsv&lt;/code&gt; 去啟動並監管（supervise）。看起來也算簡單明瞭，但可惜的是 &lt;code&gt;runsvdir&lt;/code&gt; 並不適合直接作為 PID 1 使用，原因是他不做訊號轉送，因此 &lt;code&gt;docker stop&lt;/code&gt; 會導致 container 裡所有服務直接終結。&lt;/p&gt;

&lt;p&gt;Runit 裡真正負責 PID 1 的是另一隻叫 &lt;code&gt;runit-init&lt;/code&gt; 的程式，&lt;code&gt;runit-init&lt;/code&gt; 啟動之後會把自己替換為 &lt;code&gt;runit&lt;/code&gt;，然後再叫出 &lt;code&gt;runsvdir&lt;/code&gt;，於是整個 process tree 大概就會變這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;runit ─── runsvdir ─┬─ runsv syslog-ng ─── syslog-ng -F
      	            ├─ runsv sshd ─── /usr/sbin/sshd -D
                    ├─ runsv crond ─── /usr/sbin/crond -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了 process tree 深度增加一層不太爽之外，&lt;code&gt;runit-init&lt;/code&gt; 還另外引進了 run level 的問題，同樣的，只是為了在 container 裡多跑幾個服務要搞這麼多東西似乎有點小題大做了。&lt;/p&gt;

&lt;h2 id=&#34;s6:8ac442f540b3d692a677bf03e4d50441&#34;&gt;s6&lt;/h2&gt;

&lt;p&gt;終於來到今天的主角了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://skarnet.org/software/s6/index.html&#34;&gt;s6&lt;/a&gt;，Written in C，所有 binary 加起來不到 900KB，非常輕量（也非常冷門）。主要有兩隻程式在工作：&lt;code&gt;s6-svscan&lt;/code&gt; 作為 PID 1 掃描所有服務並交由 &lt;code&gt;s6-supervise&lt;/code&gt; 實際啟動並接管。&lt;/p&gt;

&lt;p&gt;關於 &lt;code&gt;s6-svscan&lt;/code&gt; 的幾件事：
  - 收到 &lt;code&gt;docker stop&lt;/code&gt; 送進來的 SIGTERM 後，轉送給所有 &lt;code&gt;s6-supervise&lt;/code&gt; process 後接著執行 &lt;code&gt;.s6-svscan/finish&lt;/code&gt;，如果執行過程中 fail 掉就改跑 &lt;code&gt;.s6-svscan/crash&lt;/code&gt;。
  - service directory 裡每個 service 可以有三個可執行檔：run/finish/crash，顧名思義簡單易用。
  - 支援特殊 logger service，透過新建名為 &lt;code&gt;log&lt;/code&gt; 的 service directory 可以自定義 logger。
  - 會一直在背景默默的持續 scan 目錄並回收系統裡的 orphan。&lt;/p&gt;

&lt;p&gt;關於 &lt;code&gt;s6-supervise&lt;/code&gt; 的幾件事：
  - 會先切換到服務的 service directory，接著預設執行 &lt;code&gt;./run&lt;/code&gt;。
  - &lt;code&gt;./run&lt;/code&gt; 跑完了如果目錄裡存在 &lt;code&gt;./finish&lt;/code&gt; 就執行。
  - &lt;code&gt;./finish&lt;/code&gt; 如果在五秒內沒有退出，會直接被 kill 掉，然後再回頭執行 &lt;code&gt;./run&lt;/code&gt;（這個行為可以自己控制）。&lt;/p&gt;

&lt;p&gt;我的 service directory 結構長這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# tree /service
/service
|-- nginx
|   |-- event
|   |-- run
|   `-- supervise
|       |-- control
|       |-- lock
|       `-- status
|-- php5-fpm
|   |-- event
|   |-- run
|   `-- supervise
|       |-- control
|       |-- lock
|       `-- status
`-- rtorrent
    |-- event
    |-- finish
    |-- run
    `-- supervise
        |-- control
        |-- lock
        `-- status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;試用過後發現 init process 四個基本需求都有滿足，也夠簡單。但是發現另一個問題：&lt;code&gt;s6-svscan&lt;/code&gt; 把 SIGTERM 送給 &lt;code&gt;s6-supervise&lt;/code&gt; 後馬上就退出了，導致 &lt;code&gt;s6-supervise&lt;/code&gt; 管轄的服務根本沒時間 graceful shutdown，這樣子 SIGTERM 有送豈不等於沒送？當然了，在 &lt;code&gt;.s6-svscan/finish&lt;/code&gt; 裡加一段 sleep 可以 work around，但這樣搞實在不太科學。後來才知道 s6 裡有一隻叫 &lt;code&gt;s6-svwait&lt;/code&gt; 的 user interface 可以用來等待特定或所有服務，於是在 &lt;code&gt;.s6-svscan/finish&lt;/code&gt; 加上一段等待主要服務結束的指令：&lt;code&gt;exec s6-svwait -d /service/rtorrent&lt;/code&gt;，這個問題算是解決。&lt;/p&gt;

&lt;p&gt;到此，一個輕量又簡單易用的 init process 解決方案就有了。&lt;/p&gt;

&lt;h2 id=&#34;取得-s6-的-static-binaries:8ac442f540b3d692a677bf03e4d50441&#34;&gt;取得 s6 的 static binaries&lt;/h2&gt;

&lt;p&gt;參考網路上找到的&lt;a href=&#34;https://github.com/jprjr/docker-misc/blob/s6-builder/dockerfiles/arch-s6-builder/build.sh&#34;&gt;做法&lt;/a&gt;，先 build 一個基於 Arch 的 utility image 提供 s6 編譯環境，然後在其他要用到 s6 的 image repository 直接取用編好的 binary &lt;a href=&#34;https://github.com/kfei/s6-builder/blob/master/dist/s6-1.1.3.2-musl-static.tar.xz?raw=true&#34;&gt;tar ball&lt;/a&gt;。具體用法可以參考我的 GitHub &lt;a href=&#34;https://github.com/kfei/s6-builder&#34;&gt;repo&lt;/a&gt;，或者直接把 binary 抓去試試也行。&lt;/p&gt;

&lt;h2 id=&#34;寫在後面:8ac442f540b3d692a677bf03e4d50441&#34;&gt;寫在後面&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;s6 似乎沒有處理啟動順序相依性的框架，如果需要可能要自己用 hook 的方法 work around。但話說回來，在 container 裡跑多服務跑到出現複雜的啟動相依性，好像也有點怪怪的（container VM 化？）。不過如果真的要這樣搞，那你需要的應該是更完整（肥）的 init process。&lt;/li&gt;
&lt;li&gt;如果只是要處理 signal forward 讓服務可以 graceful shutdown，則完全沒有必要引入 init process，透過一隻 Bash wrapper 加幾行 trap/wait 就可以辦到，強者我同事 &lt;a href=&#34;https://github.com/tsaikd&#34;&gt;Bash 狂人&lt;/a&gt; 就是這樣搞的。&lt;/li&gt;
&lt;li&gt;Survey 的過程中發現&lt;a href=&#34;http://blog.chazomatic.us/2014/06/18/multiple-processes-inside-docker/&#34;&gt;有人&lt;/a&gt;遇到一樣的問題，然後寫了一個叫 &lt;a href=&#34;https://github.com/chazomaticus/minit&#34;&gt;minit&lt;/a&gt; 的輕量 init process，看起來也還不錯，但我沒有試，如果你有使用心得歡迎分享。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;references:8ac442f540b3d692a677bf03e4d50441&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://phusion.github.io/baseimage-docker/&#34;&gt;http://phusion.github.io/baseimage-docker/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.tutum.co/2014/12/02/docker-and-s6-my-new-favorite-process-supervisor/&#34;&gt;http://blog.tutum.co/2014/12/02/docker-and-s6-my-new-favorite-process-supervisor/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.chazomatic.us/2014/06/18/multiple-processes-inside-docker/&#34;&gt;http://blog.chazomatic.us/2014/06/18/multiple-processes-inside-docker/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>